import { devLog } from '~/utils/logger'

/**
 * Composable for managing a session-based data cache that bridges SSR and Client-side.
 * This cache uses Nuxt's `useState` to transfer data from server to client during hydration,
 * and `sessionStorage` to persist that data across page navigations in the same browser session.
 * 
 * Cache entries expire after 30 minutes to prevent stale data.
 */
export const useDataCache = () => {
  /**
   * Cache TTL in milliseconds (30 minutes)
   */
  const CACHE_TTL = 30 * 60 * 1000; // 30 minutes

  /**
   * The SSR bridge state. Nuxt automatically serializes this into the page payload.
   * Format: { [cacheKey: string]: { data: any, timestamp: number } }
   * Note: This persists during the session for client-side navigation. It's synced to
   * sessionStorage on mount but kept in memory for fast access during navigation.
   */
  const ssrBridge = useState<Record<string, { data: any; timestamp: number }>>('ssr-data-cache', () => ({}));

  /**
   * Generates a stable unique cache key from request parameters.
   * Ensures that object property order doesn't affect the resulting key.
   * 
   * @param params - The parameters used for the dataProvider request
   * @returns A stable stringified hash-like key
   */
  const generateKey = (params: any): string => {
    // Stable stringify to handle object property order
    const stableStringify = (obj: any): string => {
      if (obj === null || typeof obj !== 'object') {
        return String(obj);
      }
      if (Array.isArray(obj)) {
        return '[' + obj.map(stableStringify).join(',') + ']';
      }
      const keys = Object.keys(obj).sort();
      return '{' + keys.map(k => `${k}:${stableStringify(obj[k])}`).join(',') + '}';
    };

    return stableStringify(params);
  };

  /**
   * Checks if a cache entry is still valid (not expired).
   * 
   * @param timestamp - The timestamp when the entry was cached
   * @returns true if the entry is still valid, false if expired
   */
  const isCacheValid = (timestamp: number): boolean => {
    const now = Date.now();
    return (now - timestamp) < CACHE_TTL;
  };

  /**
   * Retrieves data from the multi-layer cache.
   * Layer 1: Browser sessionStorage (available on both SSR and client)
   * Layer 2: Nuxt useState SSR bridge (for hydration and client-side navigation)
   * 
   * @param key - The cache key generated by generateKey
   * @returns The cached data or null if not found or expired
   */
  const getCachedData = (key: string): any | null => {
    // 1. Check sessionStorage first (works on both SSR hydration and client-side navigation)
    // Note: sessionStorage is only available on client, but we check it first when available
    if (import.meta.client && typeof sessionStorage !== 'undefined') {
      try {
        const stored = sessionStorage.getItem(`mr-cache:${key}`);
        if (stored) {
          const parsed = JSON.parse(stored);
          // Check if it's the new format with timestamp
          if (parsed && typeof parsed === 'object' && 'timestamp' in parsed && 'data' in parsed) {
            if (isCacheValid(parsed.timestamp)) {
              devLog('Cache', `Hit (SessionStorage): ${key.substring(0, 40)}...`);
              // Also update SSR bridge for faster subsequent access
              ssrBridge.value[key] = parsed;
              return parsed.data;
            } else {
              // Expired - remove it
              sessionStorage.removeItem(`mr-cache:${key}`);
              devLog('Cache', `Expired entry removed: ${key.substring(0, 40)}...`);
            }
          } else {
            // Legacy format (no timestamp) - treat as expired
            sessionStorage.removeItem(`mr-cache:${key}`);
            devLog('Cache', `Legacy entry removed: ${key.substring(0, 40)}...`);
          }
        }
      } catch (e) {
        console.warn('[useDataCache] Failed to read from sessionStorage', e);
      }
    }

    // 2. Check the SSR bridge (for SSR hydration and client-side navigation)
    const ssrEntry = ssrBridge.value[key];
    if (ssrEntry && isCacheValid(ssrEntry.timestamp)) {
      devLog('Cache', `Hit (SSR Bridge): ${key.substring(0, 40)}...`);
      return ssrEntry.data;
    } else if (ssrEntry) {
      // Expired entry in SSR bridge - remove it
      delete ssrBridge.value[key];
    }

    return null;
  };

  /**
   * Stores data in the multi-layer cache with timestamp.
   * 
   * @param key - The cache key generated by generateKey
   * @param data - The data to cache
   */
  const setCachedData = (key: string, data: any): void => {
    devLog('Cache', `Storing: ${key.substring(0, 40)}...`);
    const timestamp = Date.now();
    const cacheEntry = { data, timestamp };

    // Store in SSR bridge (only for current request hydration)
    ssrBridge.value[key] = cacheEntry;

    // Store in sessionStorage if on client side
    if (import.meta.client) {
      try {
        sessionStorage.setItem(`mr-cache:${key}`, JSON.stringify(cacheEntry));
      } catch (e) {
        // Handle QuotaExceededError or other storage issues
        console.warn('[useDataCache] Failed to write to sessionStorage', e);
      }
    }
  };

  /**
   * Cleans up expired entries from sessionStorage.
   */
  const cleanupExpiredEntries = (): void => {
    if (!import.meta.client) return;

    try {
      const keysToRemove: string[] = [];
      for (let i = 0; i < sessionStorage.length; i++) {
        const key = sessionStorage.key(i);
        if (key && key.startsWith('mr-cache:')) {
          try {
            const stored = sessionStorage.getItem(key);
            if (stored) {
              const parsed = JSON.parse(stored);
              if (parsed && typeof parsed === 'object' && 'timestamp' in parsed) {
                if (!isCacheValid(parsed.timestamp)) {
                  keysToRemove.push(key);
                }
              } else {
                // Legacy format - remove it
                keysToRemove.push(key);
              }
            }
          } catch (e) {
            // Invalid entry - remove it
            keysToRemove.push(key);
          }
        }
      }
      keysToRemove.forEach(key => sessionStorage.removeItem(key));
      if (keysToRemove.length > 0) {
        devLog('Cache', `Cleaned up ${keysToRemove.length} expired entries`);
      }
    } catch (e) {
      console.warn('[useDataCache] Cleanup failed', e);
    }
  };

  /**
   * Flushes valid data from the SSR bridge into sessionStorage.
   * Keeps SSR bridge available for client-side navigation (it persists during session).
   * Usually called once when the app is mounted on the client.
   */
  const syncSsrToSessionStorage = (): void => {
    if (!import.meta.client) return;

    // Clean up expired entries first
    cleanupExpiredEntries();

    const entries = Object.entries(ssrBridge.value);
    let syncedCount = 0;

    entries.forEach(([key, entry]) => {
      // Only sync valid (non-expired) entries
      if (isCacheValid(entry.timestamp)) {
        try {
          const storageKey = `mr-cache:${key}`;
          // Only sync if not already present (avoid overwriting newer data)
          const existing = sessionStorage.getItem(storageKey);
          if (!existing) {
            sessionStorage.setItem(storageKey, JSON.stringify(entry));
            syncedCount++;
          }
        } catch (e) {
          console.warn('[useDataCache] Sync failed for key:', key, e);
        }
      } else {
        // Remove expired entries from SSR bridge
        delete ssrBridge.value[key];
      }
    });

    if (syncedCount > 0) {
      devLog('Cache', `Synced ${syncedCount} items from SSR to SessionStorage`);
    }

    // Note: We keep SSR bridge available for client-side navigation
    // It will naturally clear when the page reloads or tab closes
    // This allows instant cache hits during client-side navigation
  };

  return {
    generateKey,
    getCachedData,
    setCachedData,
    syncSsrToSessionStorage,
  };
};

