/**
 * Composable for managing a session-based data cache that bridges SSR and Client-side.
 * This cache uses Nuxt's `useState` to transfer data from server to client during hydration,
 * and `sessionStorage` to persist that data across page navigations in the same browser session.
 */
export const useDataCache = () => {
  /**
   * The SSR bridge state. Nuxt automatically serializes this into the page payload.
   * Format: { [cacheKey: string]: any }
   */
  const ssrBridge = useState<Record<string, any>>('ssr-data-cache', () => ({}));

  /**
   * Generates a stable unique cache key from request parameters.
   * Ensures that object property order doesn't affect the resulting key.
   * 
   * @param params - The parameters used for the dataProvider request
   * @returns A stable stringified hash-like key
   */
  const generateKey = (params: any): string => {
    // Stable stringify to handle object property order
    const stableStringify = (obj: any): string => {
      if (obj === null || typeof obj !== 'object') {
        return String(obj);
      }
      if (Array.isArray(obj)) {
        return '[' + obj.map(stableStringify).join(',') + ']';
      }
      const keys = Object.keys(obj).sort();
      return '{' + keys.map(k => `${k}:${stableStringify(obj[k])}`).join(',') + '}';
    };

    return stableStringify(params);
  };

  /**
   * Retrieves data from the multi-layer cache.
   * Layer 1: Nuxt useState (priority for hydration)
   * Layer 2: Browser sessionStorage (priority for client-side navigation)
   * 
   * @param key - The cache key generated by generateKey
   * @returns The cached data or null if not found
   */
  const getCachedData = (key: string): any | null => {
    // 1. Check the SSR bridge (fastest, especially during hydration)
    if (ssrBridge.value[key]) {
      devLog('Cache', `Hit (SSR Bridge): ${key.substring(0, 40)}...`);
      return ssrBridge.value[key];
    }

    // 2. Check sessionStorage if on client side
    if (import.meta.client) {
      try {
        const stored = sessionStorage.getItem(`mr-cache:${key}`);
        if (stored) {
          devLog('Cache', `Hit (SessionStorage): ${key.substring(0, 40)}...`);
          const parsed = JSON.parse(stored);
          // Optional: You could add a timestamp/TTL check here
          return parsed;
        }
      } catch (e) {
        console.warn('[useDataCache] Failed to read from sessionStorage', e);
      }
    }

    return null;
  };

  /**
   * Stores data in the multi-layer cache.
   * 
   * @param key - The cache key generated by generateKey
   * @param data - The data to cache
   */
  const setCachedData = (key: string, data: any): void => {
    devLog('Cache', `Storing: ${key.substring(0, 40)}...`);
    // Store in SSR bridge
    ssrBridge.value[key] = data;

    // Store in sessionStorage if on client side
    if (import.meta.client) {
      try {
        sessionStorage.setItem(`mr-cache:${key}`, JSON.stringify(data));
      } catch (e) {
        // Handle QuotaExceededError or other storage issues
        console.warn('[useDataCache] Failed to write to sessionStorage', e);
      }
    }
  };

  /**
   * Flushes all data from the SSR bridge into sessionStorage.
   * Usually called once when the app is mounted on the client.
   */
  const syncSsrToSessionStorage = (): void => {
    if (!import.meta.client) return;

    const entries = Object.entries(ssrBridge.value);
    if (entries.length > 0) {
      devLog('Cache', `Syncing ${entries.length} items from SSR to SessionStorage`);
    }

    entries.forEach(([key, data]) => {
      try {
        const storageKey = `mr-cache:${key}`;
        if (!sessionStorage.getItem(storageKey)) {
          sessionStorage.setItem(storageKey, JSON.stringify(data));
        }
      } catch (e) {
        console.warn('[useDataCache] Sync failed for key:', key, e);
      }
    });
  };

  return {
    generateKey,
    getCachedData,
    setCachedData,
    syncSsrToSessionStorage,
  };
};

